
// Histogram

// Not really a columnar thing, so better suited for a hashmap
// datastructure or KV database if persistence is desired
// or possible
//
// One method:
// - create two hashmaps
// - start using one at a 5-minute boundary
// - maintain statistics for incoming well-known domains
// - if size is too great or 5 minutes have passed:
//   - shift to writing other hashmap
//   - output first hashmap to parquet
//   - clear first hashmap
// - iterate

// Internal structure
// ------------------

// key
fqdn:string;
// data
struct stats {
  a_count:uint64; 
  aaaa_count:uint64; 
  mx_count:uint64; 
  ns_count:uint64; 
  other_count:uint64; 
  non_IN_count:[uint64];
  ok_count:[uint64];
  nx_count:[uint64];
  fail_count:[uint64];
  v4client_count:[ubyte];  // HLL sketch (12kB)
  v6client_count:[ubyte];  // HLL sketch (12kB)
}

// TODO possible enhancements
// Add other counters
// DNSsec valid
// Add min, max response size
// List of response addresses?


// Output to parquet
// -----------------
table HistogramRow {
  // FQDN as key
  label0:string;    // com, edu, se, uk, etc
  label1:string;    // ac, co, google, etc
  label2:string;    // www, mail, etc
  label3:string;
  label4:string;
  label5:string;
  label6:string;
  label7:string;
  label8:string;
  label9:string;    // remainder

  // Query count
  
  // Queries by type
  a_count:[uint64];
  aaaa_count:[uint64];
  mx_count:[uint64];
  ns_count:[uint64];
  other_count:[uint64];

  // Queries by class
  non_IN_count:[uint64];

  // Queries by opcode
  ok_count:[uint64];
  nx_count:[uint64];
  fail_count:[uint64];

  // Client count HLL+
  v4client_count:[ubyte];
  v6client_count:[ubyte];

}


