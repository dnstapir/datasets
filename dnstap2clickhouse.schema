// IDN

namespace dnstapir.se;

struct TimeStamp {
  s:uint64;
  ns:uint32;
}

struct IPv4 {
  adress:uint32;
}

struct IPv6 {
  network:uint64;
  host:uint64;
}

union Address {
  IPv4,
  IPv6
}

enum DNSproto : ubyte { 
    UDP = 1;         // DNS over UDP transport (RFC 1035 section 4.2.1)
    TCP = 2;         // DNS over TCP transport (RFC 1035 section 4.2.2)
    DOT = 3;         // DNS over TLS (RFC 7858)
    DOH = 4;         // DNS over HTTPS (RFC 8484)
    DNSCryptUDP = 5; // DNSCrypt over UDP (https://dnscrypt.info/protocol)
    DNSCryptTCP = 6; // DNSCrypt over TCP (https://dnscrypt.info/protocol)
    DOQ = 7;         // DNS over QUIC (RFC 9250)
}

struct Header {
  id:uint16;
  flags:uint16;
}

struct ServerState {
  key:[ubyte];
  value:[ubyte];
}

struct Counters {
  qd:uint16;
  an:uint16;
  ns:uint16;
  ar:uint16;
}

table Rd_Generic {
  data:[ubyte];
}

table Rd_A {
  data:IPv4;
}

table Rd_AAAA {
  data:IPv6;
}

union RecordData {
  RdGeneric,
  RdA,
  RdAAAA
}

struct ResourceRecord {
  name:string;
  type:uint16;
  class:uint16;
  ttl:uint32;
  rdlength:uint16;
  rdata:RecordData;
}


enum Match {
  QNAME = 1;       // Name in question section of query
  CLIENT_IP = 2;   // Client IP address
  RESPONSE_IP = 3; // Address in A/AAAA RRSet
  NS_NAME = 4;     // Authoritative name server, by name
  NS_IP = 5;       // Authoritative name server, by IP address
}

enum Action {
  NXDOMAIN = 1;   // Respond with NXDOMAIN
  NODATA = 2;     // Respond with empty answer section
  PASS = 3;       // Do not alter the response (passthrough)
  DROP = 4;       // Do not respond.
  TRUNCATE = 5;   // Truncate UDP response, forcing TCP retry
  LOCAL_DATA = 6; // Respond with local data from policy
}

struct Policy {
  // Directly from DNStap - RPZ centric

  // May need splitting into bits if policy exists in disparate 
  // bits of code

  // type: the type of policy applied, e.g. "RPZ" for a
  // policy from a Response Policy Zone.
  type:[ubyte];

  // rule: the rule matched by the message.
  rule:[ubyte];

  // action: the policy action taken in response to the
  // rule match.
  action:Action;

  // match: the feature of the message exchange which matched the rule.
  match:Match;

  // The matched value. Format depends on the matched feature
  value:[ubyte];

  // The original value and what it changed to should be here

}

// DNS query session data

// Exploded DNStap data format
table DNSsessionRow {
  // FQDN as key
  // Split FQDN into labels and maintain individual columns for each
  // label - from right to left - with remaining labels above 9 in the last 
  // column
  // This generates a flat prefix tree / Trie structure
  // The reason for not using a list for the entire key is to be able to
  // partition on single labels
  label0:string;    // com, edu, se, uk, etc
  label1:string;    // ac, co, google, etc
  label2:string;    // www, mail, etc
  label3:string;
  label4:string;
  label5:string;
  label6:string;
  label7:string;
  label8:string;
  label9:[string];   // remainder

  // Wire format FQDN
  // Either here or as a resource record
  // Possibly better as the query resource 
  // record below?
  // fqdn:[ubyte];

  // Server information 
  // DNS server identifier
  server_id:[ubyte];

  // DNS TAPIR DNStap extension for 
  // matching related packets
  session_id:uint64;    

  // A Session ID created by this session
  // For example, this query caused a recursive query 
  // to be made, and the referal_id then holds the 
  // session_id of the recursive lookup
  referal_id:uint64;    

  // Internal server state, such as if the record was
  // retrieved from cache, either persistent (preloaded
  // domains) or volatile
  // Implementation dependent, keys are freeform and
  // values also
  server_state:[ServerState];

  // Timestamps

  // Offsets
  // not sure if offset from table header is wise
  // but it saves two uint64. 
  query_time_offset:uint64;
  response_time_offset:uint64;

  // Full timestamps
  query_time:TimeStamp;
  response_time:TimeStamp;

  // Transport
  // IP protocol layer
  // Source
  // implicit anyof ipv4/ipv6
  source_ipv4:IPv4;
  source_ipv6:IPv6;

  // Destination
  // implicit anyof ipv4/ipv6
  dest_ipv4:IPv4;
  dest_ipv6:IPv6;

  // IP layer flags
  flags:uint32;

  // Transport layer
  source_port:uint16;
  dest_port:uint16;
  dns_protocol:DNSproto;

  // TLS keyhash
  //future enhancement
  // Main use case is to measure the use of 
  // session key reuse in DoH, DoQ, etc as
  // this is a privacy concern
  keyhash:[ubyte];   

  // Query header data
  qheader:Header;

  // Counters in the query package should
  // always be just one query and nothing else
  // - set only if not [1,0,0,0]
  qcounters:Counters;   

  // Response header data
  rheader:Header;
  rcounters:Counters;

  // Resource records
  records:[ResourceRecord];

  // Policy actions
  policies:[Policy];

}

// Table of dnstap data records
DNSsessionBlock {
  start_time:Timestamp;
  stop_time:Timestamp;
  sessions:[DNSsessionRow];
}


// Histogram

table HistogramRow {
  // FQDN as key
  label0:string;    // com, edu, se, uk, etc
  label1:string;    // ac, co, google, etc
  label2:string;    // www, mail, etc
  label3:string;
  label4:string;
  label5:string;
  label6:string;
  label7:string;
  label8:string;
  label9:[string];   // remainder

  // Query count
  // query_count:[uint64];

  // Queries by type
  a_count:[uint64];
  aaaa_count:[uint64];
  mx_count:[uint64];
  ns_count:[uint64];
  other_count:[uint64];

  // Queries by class
  non_IN_count:[uint64];

  // Queries by opcode
  ok_count:[uint64];
  nx_count:[uint64];
  fail_count:[uint64];

  // Client count HLL+
  v4client_count:[ubyte];
  v6client_count:[ubyte];

}

table Histogram {
  start_time:TimeStamp;
  end_time:TimeStamp;
  domainlist:[HistogramRow]
}


