
// DNS index key. Split FQDN into labels and maintain individual columns for
// each label - from right to left - with remaining labels above 9 in the last 
// column
// This generates a flat prefix tree / Trie structure
// The reason for not using a list for the entire key is to be able to
// partition on single labels

1     label0          VarBinary          Content of rightmost DNS label
2     label1          VarBinary          Content of second label from the right
3     label2          VarBinary          Content of third label from the right
4     label3          VarBinary          Content of fourth label from the right
5     label4          VarBinary          Content of fifth label from the right
6     label5          VarBinary          Content of sixth label from the right
7     label6          VarBinary          Content of seventh label from the right
8     label7          VarBinary          Content of eighth label from the right
9     label8          VarBinary          Content of ninth label from the right
10    label9          List<VarBinary>    Content of all labels beyond ninth

// Source system

11    server_id       [ubyte]   UUID?
      session_id      uint64
      referal_id      uint64
      server_state    list<kvpairs>

// Time data

22    query_time      struct
        s             uint64
        ns            uint64
23    response_time   struct
        s             uint64
        ns            uint64

// Transport data

12    source_ipv4     uint32
13    source_ipv6     struct
        network       uint64
        host          uint64 
14    source_port     uint16
15    dest_ipv4       uint32
16    dest_ipv6       struct
        network       uint64
        host          uint64
17    dest_port       uint16
18    transport       enum(UDP, TCP, QUIC...)
19    protocol        enum(DNS, DoH, DoT...)
20    flags           uint32
21    keyhash         VarBinary

// Query metadata

24    qheader struct                  
        id          uint16
        flags       uint16

25    qcounters struct                set only if not [1,0,0,0]
        qd          uint16
        an          uint16
        ns          uint16
        ar          uint16

// Response metadata

26     rheader struct
         id              uint16
         flags           uint16

27      rcounters struct             set only if not [1,1,0,0]
          qd          uint16
          an          uint16
          ns          uint16
          ar          uint16


// Resource records (query, response, auth, extra)

28    list<rr:struct>

        type            uint16
        class           uint16
        ttl             uint32
        rdlength        uint16
        rdata           union

          generic          VarBinary

          a                uint32
        
          aaaa struct
            network        uint64
            host           uint64
          
          mx struct
            preference     uint16
            name           VarBinary
        
          soa struct
            mname          VarBinary
            rname          VarBinary
            serial         uint32
            refresh        uint32
            retry          uint32
            expire         uint32
            minimum        uint32

          cname            VarBinary

          hinfo struct
            cpu            VarBinary
            os             VarBinary

          ns               VarBinary

          ptr              VarBinary

          txt              VarBinary

          etc, until bored: the rest -> generic


// Policy

  list<policy>
    match
    action
    result






// IDN

namespace dnstapir.se;

struct TimeStamp {
  s:uint64;
  ns:uint64;
}

struct IPv4 {
  adress:uint32;
}

struct IPv6 {
  network:uint64;
  host:uint64;
}

struct Header {
  id:uint16;
  flags:uint16;
}

struct ServerState {
  key:[ubytes];
  value:[ubytes];
}

struct Counters {
  qd:uint16;
  an:uint16;
  ns:uint16;
  ar:uint16;
}

table RdGeneric {
  data:[ubytes];
}

table RdA {
  data:IPv4;
}

table RdAAAA {
  data:IPv6;
}

union RecordData {
  RdGeneric;
  RdA;
  RdAAAA;
}

struct ResourceRecord {
  name:string;
  type:uint16;
  class:uint16;
  ttl:uint32;
  rdlength:uint16;
  rdata:RecordData;
}

struct Policy {
  match:enum
  action:enum
  ...
}

// Exploded DNStap data format
table DNSsessionRow {
  // FQDN as key
  // Split FQDN into labels and maintain individual columns for each
  // label - from right to left - with remaining labels above 9 in the last 
  // column
  // This generates a flat prefix tree / Trie structure
  // The reason for not using a list for the entire key is to be able to
  // partition on single labels
  label0:string;    // com, edu, se, uk, etc
  label1:string;    // ac, co, google, etc
  label2:string;    // www, mail, etc
  label3:string;
  label4:string;
  label5:string;
  label6:string;
  label7:string;
  label8:string;
  label9:[string];

  // Wire format FQDN
  // Either here or as a resource record
  // Possibly better as the query resource 
  // record below
  // fqdn:[ubyte];

  // Server information 
  // DNS server identifier
  server_id:[ubyte];

  // DNS TAPIR DNStap extension for 
  // matching related packets
  session_id:uint64;    

  // A Session ID created by this session
  // For example, this query caused a recursive query 
  // to be made, and the referal_id then holds the 
  // session_id of the recursive lookup
  referal_id:uint64;    

  // Internal server state, such as if the record was
  // retrieved from cache, either persistent (preloaded
  // domains) or volatile
  // Implementation dependent, keys are freeform and
  // values also
  server_state:[ServerState];

  // Timestamps
  // not sure if offset from table header is wise
  // but it saves two uint64. 
  query_time_offset:uint64;
  response_time_offset:uint64;

  // Transport
  source_ipv4:IPv4;
  source_ipv6:IPv6;
  source_port:uint16;
  dest_ipv4:IPv4;
  dest_ipv6:IPv6;
  dest_port:uint16;

  transport:enum?;
  protocol:enum?;

  // IP layer flags
  flags:uint32;

  // TLS keyhash
  //future enhancement
  // Main use case is to measure the use of 
  // session key reuse in DoH, DoQ, etc as
  // this is a privacy concern
  keyhash:[ubyte];   

  // Query header data
  qheader:Header;

  // Counters in the query package should
  // always be just one query and nothing else
  // - set only if not [1,0,0,0]
  qcounters:Counters;   

  // Response header data
  rheader:Header;
  rcounters:Counters;

  // Resource records
  records:[ResourceRecord];

  // Policy actions
  policies:[Policy];

}

// Table of dnstap data records
DNSsessionBlock {
  start_time:Timestamp;
  stop_time:Timestamp;
  sessions:[DNSsessionRow];
}


// Histogram table

table HistogramRow {
  // FQDN as key
  label0:string;    // com, edu, se, uk, etc
  label1:string;    // ac, co, google, etc
  label2:string;    // www, mail, etc
  label3:string;
  label4:string;
  label5:string;
  label6:string;
  label7:string;
  label8:string;
  label9:[string];

  query_count:[uint64];
  a_count:
  aaaa_count
  mx_count
  ns_count
  ...
  non_IN_count:[uint64];
  error_count:[uint64];
  nx_count:[uint64];

  v4client_count:[ubyte];
  v6client_count:[ubyte];

}

table Histogram {
  start_time:TimeStamp;
  end_time:TimeStamp;
  domainlist:[HistogramRow]
}





Parquet style schema

message DNSsession {



